import { spawn } from 'node:child_process';
import fs from 'node:fs/promises';
import path from 'node:path';
import { getProto } from './lib/proto.js';
import { getParams } from './lib/params.js';
import { languages } from './types/language.js';
function whisper(audio, options = {}) {
    return new Promise((resolve, reject) => {
        const params = [audio, ...getParams(options)];
        if (options.verbose) {
            console.log('command:', params);
        }
        const whisper = spawn('whisper', params);
        whisper.on('error', reject);
        whisper.stdout.on('data', (data) => {
            if (options.verbose) {
                console.log('stdout:', data.toString());
            }
        });
        let error = '';
        whisper.stderr.on('data', (data) => {
            if (options.verbose) {
                console.log('stderr:', data.toString());
            }
            error += data.toString();
        });
        whisper.on('close', (code) => {
            if (options.verbose) {
                console.log('Whisper process exit with code:', code);
            }
            if (code === null || code > 0) {
                reject(new Error(`Whisper error: ${error.toString()}, CODE: ${code?.toString() ?? ''}`));
                return;
            }
            const folder = options.output_dir ?? '.';
            const name = path.basename(audio).replace(path.extname(audio), '');
            if (!options.output_format || options.output_format === 'all') {
                const json = `${folder}/${name}.json`;
                const tsv = `${folder}/${name}.tsv`;
                const srt = `${folder}/${name}.srt`;
                const vtt = `${folder}/${name}.vtt`;
                const txt = `${folder}/${name}.txt`;
                resolve({
                    json: getProto('json', json),
                    tsv: getProto('tsv', tsv),
                    srt: getProto('srt', srt),
                    vtt: getProto('vtt', vtt),
                    txt: getProto('txt', txt),
                });
            }
            else {
                const custom = `${folder}/${name}.${options.output_format}`;
                resolve({
                    [options.output_format]: getProto(options.output_format, custom),
                });
            }
        });
    });
}
whisper.languages = languages;
whisper.readAllFiles = async (input) => {
    const output = {};
    for (const [k, value] of Object.entries(input)) {
        const key = k;
        const content = await fs.readFile(value.file, { encoding: 'utf8' });
        output[key] = key === 'json' ? JSON.parse(content) : content;
    }
    return output;
};
export default whisper;
//# sourceMappingURL=whisper.js.map