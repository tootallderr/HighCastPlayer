"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_child_process_1 = require("node:child_process");
const promises_1 = __importDefault(require("node:fs/promises"));
const node_path_1 = __importDefault(require("node:path"));
const proto_js_1 = require("./lib/proto.js");
const params_js_1 = require("./lib/params.js");
const language_js_1 = require("./types/language.js");
function whisper(audio, options = {}) {
    return new Promise((resolve, reject) => {
        const params = [audio, ...(0, params_js_1.getParams)(options)];
        if (options.verbose) {
            console.log('command:', params);
        }
        const whisper = (0, node_child_process_1.spawn)('whisper', params);
        whisper.on('error', reject);
        whisper.stdout.on('data', (data) => {
            if (options.verbose) {
                console.log('stdout:', data.toString());
            }
        });
        let error = '';
        whisper.stderr.on('data', (data) => {
            if (options.verbose) {
                console.log('stderr:', data.toString());
            }
            error += data.toString();
        });
        whisper.on('close', (code) => {
            if (options.verbose) {
                console.log('Whisper process exit with code:', code);
            }
            if (code === null || code > 0) {
                reject(new Error(`Whisper error: ${error.toString()}, CODE: ${code?.toString() ?? ''}`));
                return;
            }
            const folder = options.output_dir ?? '.';
            const name = node_path_1.default.basename(audio).replace(node_path_1.default.extname(audio), '');
            if (!options.output_format || options.output_format === 'all') {
                const json = `${folder}/${name}.json`;
                const tsv = `${folder}/${name}.tsv`;
                const srt = `${folder}/${name}.srt`;
                const vtt = `${folder}/${name}.vtt`;
                const txt = `${folder}/${name}.txt`;
                resolve({
                    json: (0, proto_js_1.getProto)('json', json),
                    tsv: (0, proto_js_1.getProto)('tsv', tsv),
                    srt: (0, proto_js_1.getProto)('srt', srt),
                    vtt: (0, proto_js_1.getProto)('vtt', vtt),
                    txt: (0, proto_js_1.getProto)('txt', txt),
                });
            }
            else {
                const custom = `${folder}/${name}.${options.output_format}`;
                resolve({
                    [options.output_format]: (0, proto_js_1.getProto)(options.output_format, custom),
                });
            }
        });
    });
}
whisper.languages = language_js_1.languages;
whisper.readAllFiles = async (input) => {
    const output = {};
    for (const [k, value] of Object.entries(input)) {
        const key = k;
        const content = await promises_1.default.readFile(value.file, { encoding: 'utf8' });
        output[key] = key === 'json' ? JSON.parse(content) : content;
    }
    return output;
};
exports.default = whisper;
//# sourceMappingURL=whisper.js.map